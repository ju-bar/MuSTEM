!--------------------------------------------------------------------------------
!
!  Copyright (C) 2025  L. J. Allen, H. G. Brown, A. J. Dâ€™Alfonso, S.D. Findlay, 
!                      B. D. Forbes, J. Barthel
!
!  modified:
!  - J. Barthel, 2025-06-26 - removed unused interface variables
!  - J. Barthel, 2025-08-20 - added C2R, R2C, Z2D, D2Z 2d execution interfaces
!                        note (n1, n2) -> (n1/2+1, n2) for R2C transforms
!
!  This program is free software: you can redistribute it and/or modify
!  it under the terms of the GNU General Public License as published by
!  the Free Software Foundation, either version 3 of the License, or
!  (at your option) any later version.
!  
!  This program is distributed in the hope that it will be useful,
!  but WITHOUT ANY WARRANTY; without even the implied warranty of
!  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!  GNU General Public License for more details.
!   
!  You should have received a copy of the GNU General Public License
!  along with this program.  If not, see <http://www.gnu.org/licenses/>.
!                       
!--------------------------------------------------------------------------------

!
!  CUFFT_wrapper.f90
!
!  Free-Format Fortran Source File 
!  Generated by PGI Visual Fortran(R)
!  6/28/2011 12:38:12 PM
!
! Author:	Adrian D'Alfonso
!			uses CUDA fortran
!			requires the module files 
!					1) precision.f90 
!					2) mod_cufft.f90
!
!			contains the subroutine channel_to_exit_abs which is a cuda implementation
!			of the multislice algorithm.
!----------------------------------------------------------------------------------------



module CUFFT_wrapper

#ifdef GPU
	use cufft
	implicit none
	save

    interface fft1
	  module procedure dfft1d
	  module procedure sfft1d
	end interface fft1

    interface ifft1
	  module procedure dfft1b
	  module procedure sfft1b
	end interface ifft1

    interface fft2
	  module procedure dfft2d     ! double complex -> double complex
	  module procedure sfft2d     ! single complex -> single complex
	  module procedure drfft2d    ! double real -> double complex
	  module procedure srfft2d    ! single real -> single complex
	end interface fft2

    interface ifft2
	  module procedure dfft2b     ! double complex -> double complex
      module procedure sfft2b     ! single complex -> single complex
	  module procedure drfft2b    ! double complex -> double real
	  module procedure srfft2b    ! single complex -> single real
	end interface ifft2

    interface fft3
	  module procedure dfft3d
	  module procedure sfft3d
	end interface fft3

    interface ifft3
	  module procedure dfft3b
	  module procedure sfft3b
	end interface ifft3



    contains
!	forward 1D transform
	
    subroutine dfft1d(n,array_in,array_out)

	implicit none
	integer	plan
	integer(4) :: n
	complex(8),dimension(n) :: array_in
	complex(8),dimension(n) :: array_out

	!device arrays
	complex(8),device,dimension(n) :: array_in_d
	complex(8),device,dimension(n) :: array_out_d
	
	!copy data to device
	array_in_d=array_in

	! Initialize the plan
	call cufftPlan(plan,n,CUFFT_Z2Z)

	! Execute FFTs
	call cufftExec(plan,array_in_d,array_out_d,CUFFT_FORWARD)

	! Destroy plans
	call cufftDestroy(plan)

	! Copy results back to host
	array_out=array_out_d

    array_out=array_out/(dsqrt(dfloat(n)))
	return
	end subroutine

!----------------------------------------------------------------------------------------
!	inverse 1D transform
	subroutine dfft1b(n,array_in,array_out)

	implicit none
	integer	plan
	integer(4) :: n
	complex(8),dimension(n) :: array_in
	complex(8),dimension(n) :: array_out

	!device arrays
	complex(8),device,dimension(n) :: array_in_d
	complex(8),device,dimension(n) :: array_out_d
	
	!copy data to device
	array_in_d=array_in

	! Initialize the plan
	call cufftPlan(plan,n,CUFFT_Z2Z)

	! Execute FFTs
	call cufftExec(plan,array_in_d,array_out_d,CUFFT_INVERSE)

	! Destroy plans
	call cufftDestroy(plan)

	! Copy results back to host
	array_out=array_out_d

    array_out=array_out/(dsqrt(dfloat(n)))

	return
	end subroutine
	





!----------------------------------------------------------------------------------------
!	forward 2D transform
	subroutine dfft2d(ny,nx,array_in,array_out)

	implicit none
	integer	plan
	integer(4) :: ny,nx
	complex(8),dimension(ny,nx) :: array_in
	complex(8),dimension(ny,nx) :: array_out

	!device arrays
	complex(8),device,dimension(ny,nx) :: array_in_d
	complex(8),device,dimension(ny,nx) :: array_out_d
	
	!copy data to device
	array_in_d=array_in

	! Initialize the plan - reversed dimensions of the cufftPlan2d API
	call cufftPlan(plan,nx,ny,CUFFT_Z2Z)

	! Execute FFTs
	call cufftExec(plan,array_in_d,array_out_d,CUFFT_FORWARD)

	! Destroy plans
	call cufftDestroy(plan)

	! Copy results back to host
	array_out=array_out_d
    array_out=array_out/(dsqrt(dfloat(ny*nx)))
	return
    end subroutine
    
    subroutine drfft2d(ny,nx,array_in,array_out)

	implicit none
	integer	plan
	integer(4) :: ny,nx
	real(8),dimension(ny,nx) :: array_in
	complex(8),dimension(ny/2+1,nx) :: array_out

	!device arrays
	real(8),device,dimension(ny,nx) :: array_in_d
	complex(8),device,dimension(ny/2+1,nx) :: array_out_d
	
	!copy data to device
	array_in_d=array_in

	! Initialize the plan - reversed dimensions of the cufftPlan2d API
	call cufftPlan(plan,nx,ny,CUFFT_D2Z)

	! Execute FFTs
	call cufftExec(plan,array_in_d,array_out_d)

	! Destroy plans
	call cufftDestroy(plan)

	! Copy results back to host
	array_out=array_out_d
    array_out=array_out/(dsqrt(dfloat(ny*nx)))
	return
	end subroutine

!----------------------------------------------------------------------------------------
!	inverse 2D transform
	subroutine dfft2b(ny,nx,array_in,array_out)

	implicit none
	integer	plan
	integer(4) :: ny,nx
	complex(8),dimension(ny,nx) :: array_in
	complex(8),dimension(ny,nx) :: array_out

	!device arrays
	complex(8),device,dimension(ny,nx) :: array_in_d
	complex(8),device,dimension(ny,nx) :: array_out_d
	
	!copy data to device
	array_in_d=array_in

	! Initialize the plan - reversed dimensions of the cufftPlan2d API
	call cufftPlan(plan,nx,ny,CUFFT_Z2Z)

	! Execute FFTs
	call cufftExec(plan,array_in_d,array_out_d,CUFFT_INVERSE)

	! Destroy plans
	call cufftDestroy(plan)

	! Copy results back to host
	array_out=array_out_d
    array_out=array_out/(dsqrt(dfloat(ny*nx)))
	return
    end subroutine
    
    subroutine drfft2b(ny,nx,array_in,array_out)

	implicit none
	integer	plan
	integer(4) :: ny,nx
	complex(8),dimension(ny/2+1,nx) :: array_in
	real(8),dimension(ny,nx) :: array_out

	!device arrays
	complex(8),device,dimension(ny/2+1,nx) :: array_in_d
	real(8),device,dimension(ny,nx) :: array_out_d
	
	!copy data to device
	array_in_d=array_in

	! Initialize the plan - reversed dimensions of the cufftPlan2d API
	call cufftPlan(plan,nx,ny,CUFFT_Z2D)

	! Execute FFTs
	call cufftExec(plan,array_in_d,array_out_d)

	! Destroy plans
	call cufftDestroy(plan)

	! Copy results back to host
	array_out=array_out_d
    array_out=array_out/(dsqrt(dfloat(ny*nx)))
	return
	end subroutine
	
!----------------------------------------------------------------------------------------
!	forward 3D transform
	subroutine dfft3d(ny,nx,nz,array_in,array_out)

	implicit none
	integer	plan
	integer(4) :: ny,nx,nz
	complex(8),dimension(ny,nx,nz) :: array_in
	complex(8),dimension(ny,nx,nz) :: array_out

	!device arrays
	complex(8),device,dimension(ny,nx,nz) :: array_in_d
	complex(8),device,dimension(ny,nx,nz) :: array_out_d
	
	!copy data to device
	array_in_d=array_in

	! Initialize the plan - reversed dimensions of the cufftPlan3d API
	call cufftPlan(plan,nz,nx,ny,CUFFT_Z2Z)

	! Execute FFTs
	call cufftExec(plan,array_in_d,array_out_d,CUFFT_FORWARD)

	! Destroy plans
	call cufftDestroy(plan)

	! Copy results back to host
	array_out=array_out_d
    array_out=array_out/(dsqrt(dfloat(ny*nx*nz)))
	return
	end subroutine

!----------------------------------------------------------------------------------------
!	inverse 3D transform
	subroutine dfft3b(ny,nx,nz,array_in,array_out)

	implicit none
	integer	plan
	integer(4) :: ny,nx,nz
	complex(8),dimension(ny,nx,nz) :: array_in
	complex(8),dimension(ny,nx,nz) :: array_out

	!device arrays
	complex(8),device,dimension(ny,nx,nz) :: array_in_d
	complex(8),device,dimension(ny,nx,nz) :: array_out_d
	
	!copy data to device
	array_in_d=array_in

	! Initialize the plan - reversed dimensions of the cufftPlan3d API
	call cufftPlan(plan,nz,nx,ny,CUFFT_Z2Z)

	! Execute FFTs
	call cufftExec(plan,array_in_d,array_out_d,CUFFT_INVERSE)

	! Destroy plans
	call cufftDestroy(plan)

	! Copy results back to host
	array_out=array_out_d
    array_out=array_out/(dsqrt(dfloat(ny*nx*nz)))
	return
	end subroutine


    !----------------------------------------------------------------------------------------------------------------------------------



    !	forward 1D transform
	subroutine sfft1d(n,array_in,array_out)

	implicit none
	integer	plan
	integer(4) :: n
	complex(4),dimension(n) :: array_in
	complex(4),dimension(n) :: array_out

	!device arrays
	complex(4),device,dimension(n) :: array_in_d
	complex(4),device,dimension(n) :: array_out_d
	
	!copy data to device
	array_in_d=array_in

	! Initialize the plan
	call cufftPlan(plan,n,CUFFT_C2C)

	! Execute FFTs
	call cufftExec(plan,array_in_d,array_out_d,CUFFT_FORWARD)

	! Destroy plans
	call cufftDestroy(plan)

	! Copy results back to host
	array_out=array_out_d
    array_out=array_out/(sqrt(float(n)))
	return
	end subroutine

!----------------------------------------------------------------------------------------
!	inverse 1D transform
	subroutine sfft1b(n,array_in,array_out)

	implicit none
	integer	plan
	integer(4) :: n
	complex(4),dimension(n) :: array_in
	complex(4),dimension(n) :: array_out

	!device arrays
	complex(4),device,dimension(n) :: array_in_d
	complex(4),device,dimension(n) :: array_out_d
	
	!copy data to device
	array_in_d=array_in

	! Initialize the plan
	call cufftPlan(plan,n,CUFFT_C2C)

	! Execute FFTs
	call cufftExec(plan,array_in_d,array_out_d,CUFFT_INVERSE)

	! Destroy plans
	call cufftDestroy(plan)

	! Copy results back to host
	array_out=array_out_d
    array_out=array_out/(sqrt(float(n)))
	return
	end subroutine
	





!----------------------------------------------------------------------------------------
!	forward 2D transform
	subroutine sfft2d(ny,nx,array_in,array_out)

	implicit none
	integer	plan
	integer(4) :: ny,nx
	complex(4),dimension(ny,nx) :: array_in
	complex(4),dimension(ny,nx) :: array_out

	!device arrays
	complex(4),device,dimension(ny,nx) :: array_in_d
	complex(4),device,dimension(ny,nx) :: array_out_d
	
	!copy data to device
	array_in_d=array_in

	! Initialize the plan - reversed dimensions of the cufftPlan2d API
    call cufftPlan(plan,nx,ny,CUFFT_C2C)

	! Execute FFTs
	call cufftExec(plan,array_in_d,array_out_d,CUFFT_FORWARD)

	! Destroy plans
	call cufftDestroy(plan)

	! Copy results back to host
	array_out=array_out_d
    array_out=array_out/(sqrt(float(ny*nx)))
	return
    end subroutine
    
    subroutine srfft2d(ny,nx,array_in,array_out)

	implicit none
	integer	plan
	integer(4) :: ny,nx
	real(4),dimension(ny,nx) :: array_in
	complex(4),dimension(ny/2+1,nx) :: array_out

	!device arrays
	real(4),device,dimension(ny,nx) :: array_in_d
	complex(4),device,dimension(ny/2+1,nx) :: array_out_d
	
	!copy data to device
	array_in_d=array_in

	! Initialize the plan - reversed dimensions of the cufftPlan2d API
    call cufftPlan(plan,nx,ny,CUFFT_R2C)

	! Execute FFTs
	call cufftExec(plan,array_in_d,array_out_d)

	! Destroy plans
	call cufftDestroy(plan)

	! Copy results back to host
	array_out=array_out_d
    array_out=array_out/(sqrt(float(ny*nx)))
	return
	end subroutine

!----------------------------------------------------------------------------------------
!	inverse 2D transform
	subroutine sfft2b(ny,nx,array_in,array_out)

	implicit none
	integer	plan
	integer(4) :: ny,nx
	complex(4),dimension(ny,nx) :: array_in
	complex(4),dimension(ny,nx) :: array_out

	!device arrays
	complex(4),device,dimension(ny,nx) :: array_in_d
	complex(4),device,dimension(ny,nx) :: array_out_d
	
	!copy data to device
	array_in_d=array_in

	! Initialize the plan - reversed dimensions of the cufftPlan2d API
	call cufftPlan(plan,nx,ny,CUFFT_C2C)

	! Execute FFTs
	call cufftExec(plan,array_in_d,array_out_d,CUFFT_INVERSE)

	! Destroy plans
	call cufftDestroy(plan)

	! Copy results back to host
	array_out=array_out_d
    array_out=array_out/(sqrt(float(ny*nx)))
	return
    end subroutine
    
    subroutine srfft2b(ny,nx,array_in,array_out)

	implicit none
	integer	plan
	integer(4) :: ny,nx
	complex(4),dimension(ny/2+1,nx) :: array_in
	real(4),dimension(ny,nx) :: array_out

	!device arrays
	complex(4),device,dimension(ny,nx) :: array_in_d
	real(4),device,dimension(ny/2+1,nx) :: array_out_d
	
	!copy data to device
	array_in_d=array_in

	! Initialize the plan - reversed dimensions of the cufftPlan2d API
	call cufftPlan(plan,nx,ny,CUFFT_C2R)

	! Execute FFTs
	call cufftExec(plan,array_in_d,array_out_d)

	! Destroy plans
	call cufftDestroy(plan)

	! Copy results back to host
	array_out=array_out_d
    array_out=array_out/(sqrt(float(ny*nx)))
	return
	end subroutine
	
!----------------------------------------------------------------------------------------
!	forward 3D transform
	subroutine sfft3d(ny,nx,nz,array_in,array_out)

	implicit none
	integer	plan
	integer(4) :: ny,nx,nz
	complex(4),dimension(ny,nx,nz) :: array_in
	complex(4),dimension(ny,nx,nz) :: array_out

	!device arrays
	complex(4),device,dimension(ny,nx,nz) :: array_in_d
	complex(4),device,dimension(ny,nx,nz) :: array_out_d
	
	!copy data to device
	array_in_d=array_in

	! Initialize the plan - reversed dimensions of the cufftPlan3d API
	call cufftPlan(plan,nz,nx,ny,CUFFT_C2C)

	! Execute FFTs
	call cufftExec(plan,array_in_d,array_out_d,CUFFT_FORWARD)

	! Destroy plans
	call cufftDestroy(plan)

	! Copy results back to host
	array_out=array_out_d
    array_out=array_out/(sqrt(float(ny*nx*nz)))
	return
	end subroutine

!----------------------------------------------------------------------------------------
!	inverse 3D transform
	subroutine sfft3b(ny,nx,nz,array_in,array_out)

	implicit none
	integer	plan
	integer(4) :: ny,nx,nz
	complex(4),dimension(ny,nx,nz) :: array_in
	complex(4),dimension(ny,nx,nz) :: array_out

	!device arrays
	complex(4),device,dimension(ny,nx,nz) :: array_in_d
	complex(4),device,dimension(ny,nx,nz) :: array_out_d
	
	!copy data to device
	array_in_d=array_in

	! Initialize the plan - reversed dimensions of the cufftPlan2d API
	call cufftPlan(plan,nz,nx,ny,CUFFT_C2C)

	! Execute FFTs
	call cufftExec(plan,array_in_d,array_out_d,CUFFT_INVERSE)

	! Destroy plans
	call cufftDestroy(plan)

	! Copy results back to host
	array_out=array_out_d
    array_out=array_out/(sqrt(float(ny*nx*nz)))
	return
    end subroutine
    
#else


! -----------------------------------------------------------------------------
!
! CPU FFT wrapper (FFTW interface of the MKL)

  implicit none

  save

    interface fft1
	  module procedure dfft1d
	  module procedure sfft1d
	end interface fft1

    interface ifft1
	  module procedure dfft1b
	  module procedure sfft1b
	end interface ifft1

    interface fft2
	  module procedure dfft2d     ! double complex -> double complex
	  module procedure sfft2d     ! single complex -> single complex
	  module procedure drfft2d    ! double real -> double complex
	  module procedure srfft2d    ! single real -> single complex
	end interface fft2

    interface ifft2
	  module procedure dfft2b     ! double complex -> double complex
      module procedure sfft2b     ! single complex -> single complex
	  module procedure drfft2b    ! double complex -> double real
	  module procedure srfft2b    ! single complex -> single real
	end interface ifft2



    contains
          
 
    !replaced by routine setup_threading in main program
    !
    !subroutine setup_threading()
    !implicit none
    !  
    !integer*4   num_threads,junk
    !integer*4   OMP_GET_MAX_THREADS
    !external    OMP_GET_MAX_THREADS
    !
    !!Set the number of threads allowed
    !num_threads=OMP_GET_MAX_THREADS()
    !num_threads=num_threads/2
    !CALL OMP_SET_NUM_THREADS(num_threads)
    !call dfftw_init_threads(junk)
    !call dfftw_plan_with_nthreads(num_threads)
    !write(*,*) '|----------------------------------------------------------------------------|'
    !write(*,*) '        The number of threads available is: ',num_threads*2
    !write(*,*) '        The number of threads being used is: ',num_threads
    !write(*,*) '|----------------------------------------------------------------------------|'
    !return
    !end subroutine
    
    
    ! --- double-precision FFTs ---
    
    
    subroutine dfft1b(n,array_in,array_out)
	implicit none
	include 'fftw3.f'
	integer*8	plan
	integer*4	n
	complex*16  array_in(n)
	complex*16  array_out(n)

    call dfftw_plan_dft(plan,n,array_in,array_out,FFTW_BACKWARD,FFTW_ESTIMATE )
	call dfftw_execute(plan)
	call dfftw_destroy_plan(plan)
	array_out=array_out/(dsqrt(dfloat(n)))
	return
    end subroutine
    
	
	subroutine dfft1d(n,array_in,array_out)
	implicit none
	include 'fftw3.f'
	integer*8	plan
	integer*4	n
	complex*16  array_in(n)
	complex*16  array_out(n)

    call dfftw_plan_dft(plan,n,array_in,array_out,FFTW_FORWARD,FFTW_ESTIMATE )
	call dfftw_execute(plan)
	call dfftw_destroy_plan(plan)
    array_out=array_out/(dsqrt(dfloat(n)))
	return
    end subroutine
    
	
	subroutine dfft2b(ny,nx,array_in,array_out)
	implicit none
	include 'fftw3.f'
	integer*8	plan
	integer*4	ny,nx
	complex*16  array_in(ny,nx)
	complex*16  array_out(ny,nx)

    call dfftw_plan_dft_2d(plan,ny,nx,array_in,array_out,FFTW_BACKWARD,FFTW_ESTIMATE )
	call dfftw_execute(plan)
	call dfftw_destroy_plan(plan)
	array_out=array_out/(dsqrt(dfloat(ny*nx)))
	return
    end subroutine
    

	subroutine dfft2d(ny,nx,array_in,array_out)
	implicit none
	include 'fftw3.f'
	integer*8	plan
	integer*4	ny,nx
	complex*16  array_in(ny,nx)
	complex*16  array_out(ny,nx)

    call dfftw_plan_dft_2d(plan,ny,nx,array_in,array_out,FFTW_FORWARD,FFTW_ESTIMATE )
	call dfftw_execute(plan)
	call dfftw_destroy_plan(plan)
    array_out=array_out/(dsqrt(dfloat(ny*nx)))
	return
    end subroutine
    
    
    subroutine drfft2d(ny,nx,array_in,array_out) ! 2025-08-20 JB
	  implicit none
	  include 'fftw3.f'
	  integer*8 :: plan
	  integer*4 :: ny,nx
	  real*8 :: array_in(ny,nx)
	  !complex*16 :: array_out(ny,nx/2+1)
      complex*16 :: array_out(ny/2+1,nx)

	  call dfftw_plan_dft_r2c_2d(plan, ny, nx, array_in, array_out, FFTW_ESTIMATE)
	  call dfftw_execute(plan)
	  call dfftw_destroy_plan(plan)
	  array_out = array_out / dsqrt(dfloat(ny*nx))
      return
    end subroutine
    
    
    subroutine drfft2b(ny,nx,array_in,array_out) ! 2025-08-20 JB
	  implicit none
	  include 'fftw3.f'
	  integer*8 :: plan
	  integer*4 :: ny,nx
      !complex*16 :: array_in(ny,nx/2+1)
	  complex*16 :: array_in(ny/2+1,nx)
	  real*8 :: array_out(ny,nx)

	  call dfftw_plan_dft_c2r_2d(plan, ny, nx, array_in, array_out, FFTW_ESTIMATE)
	  call dfftw_execute(plan)
	  call dfftw_destroy_plan(plan)
	  array_out = array_out / dsqrt(dfloat(ny*nx))
      return
	end subroutine    
    
	
	
    ! --- single-precision FFTs ---
	
	subroutine sfft1b(n,array_in,array_out)
	implicit none
	include 'fftw3.f'
	integer*8  plan
	integer*4  n
	complex*8  array_in(n)
	complex*8  array_out(n)

    call sfftw_plan_dft(plan,n,array_in,array_out,FFTW_BACKWARD,FFTW_ESTIMATE )
	call sfftw_execute(plan)
	call sfftw_destroy_plan(plan)
	array_out=array_out/(sqrt(float(n)))
	return
    end subroutine
	
	
    subroutine sfft1d(n,array_in,array_out)
	implicit none
	include 'fftw3.f'
	integer*8 plan
	integer*4 n
	complex*8 array_in(n)
	complex*8 array_out(n)

    call sfftw_plan_dft(plan,n,array_in,array_out,FFTW_FORWARD,FFTW_ESTIMATE )
	call sfftw_execute(plan)
	call sfftw_destroy_plan(plan)
    array_out=array_out/(sqrt(float(n)))
	return
    end subroutine
    
	
	subroutine sfft2b(ny,nx,array_in,array_out)
	implicit none
	include 'fftw3.f'
	integer*8 plan
	integer*4 ny,nx
	complex*8 array_in(ny,nx)
	complex*8 array_out(ny,nx)

    call sfftw_plan_dft_2d(plan,ny,nx,array_in,array_out,FFTW_BACKWARD,FFTW_ESTIMATE )
	call sfftw_execute(plan)
	call sfftw_destroy_plan(plan)
	array_out=array_out/(sqrt(float(ny*nx)))
	return
    end subroutine
    

	subroutine sfft2d(ny,nx,array_in,array_out)
	implicit none
	include 'fftw3.f'
	integer*8 plan
	integer*4 ny,nx
	complex*8 array_in(ny,nx)
	complex*8 array_out(ny,nx)

    call sfftw_plan_dft_2d(plan,ny,nx,array_in,array_out,FFTW_FORWARD,FFTW_ESTIMATE )
	call sfftw_execute(plan)
	call sfftw_destroy_plan(plan)
    array_out=array_out/(sqrt(float(ny*nx)))
	return
    end subroutine
    
    
    subroutine srfft2d(ny,nx,array_in,array_out) ! 2025-08-20 JB
	  implicit none
	  include 'fftw3.f'
	  integer*8 :: plan
	  integer*4 :: ny,nx
	  real*4 :: array_in(ny,nx)
	  !complex*8 :: array_out(ny,nx/2+1)
      complex*8 :: array_out(ny/2+1,nx)
      
	  call sfftw_plan_dft_r2c_2d(plan, ny, nx, array_in, array_out, FFTW_ESTIMATE)
	  call sfftw_execute(plan)
	  call sfftw_destroy_plan(plan)
	  array_out = array_out / sqrt(real(ny*nx,kind=4))
      return
    end subroutine
    
    
    subroutine srfft2b(ny,nx,array_in,array_out) ! 2025-08-20 JB
	  implicit none
	  include 'fftw3.f'
	  integer*8 :: plan
	  integer*4 :: ny,nx
	  !complex*8 :: array_in(ny,nx/2+1)
      complex*8 :: array_in(ny/2+1,nx)
	  real*4 :: array_out(ny,nx)

	  call sfftw_plan_dft_c2r_2d(plan, ny, nx, array_in, array_out, FFTW_ESTIMATE)
	  call sfftw_execute(plan)
	  call sfftw_destroy_plan(plan)
	  array_out = array_out / sqrt(real(ny*nx,kind=4))
      return
	end subroutine

#endif

end module CUFFT_wrapper


